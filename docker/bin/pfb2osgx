#!/bin/bash



#input a terrain mesh directory, and will make a directory containing processed obj/mtl s.

if [ $# -ne 2 ] || [ $1 = "-h" ] ; then
	echo "Usage:  pfb2osgx <pfb file path> <osgx file path>"
	echo ""
	echo "This will convert the pfb to osgx format using openscenegraph osgcov."
	echo "But since that sometimes stalls, this script monitors it, and kills"
	echo "and restarts the process if necessary."
	exit 0
fi

function clean_up_semaphores {

	#clean up semaphores
	#delete the ones created by this user whose mod times are more recent than the time we began this script
	#also delete any that are more than 2hours old
	semlist=$(ipcs -s -t)
	OIFS="${IFS}"
	NIFS=$'\n'
	IFS="${NIFS}"
	for line in ${semlist} ; do
	        id=`expr "$line" :  "^\([0-9]*\)\s*${USER}.*"`
	 	echo $id;
	        timetag=`expr "$line" :  ".*${USER}.*\([a-zA-Z][a-zA-Z][a-zA-Z]\s[a-zA-Z][a-zA-Z][a-zA-Z]\s*[0-9]*\s[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\s20[0-9][0-9]\)"`
		echo $timetag 
	        if [[ "$id" != "" ]] ; then
	                secs=$(date --date="${timetag}" +%s)  #get the date returned as a total num secs since 1970
	                if [ $secs -gt $startsecs ] ; then
	                        ipcrm -s ${id}
				echo "removing ${id}"
	                fi
			diff=$((startsecs-secs)) #diff between the creation time of the semaphore and when this script started
			if [ $diff -gt 7200 ] ; then 
				ipcrm -s ${id}
                                echo "removing ${id}"
                        fi
	        fi

	done
	IFS="${OIFS}"
}


#to clean up semaphores from building up, keep track of the time, so know which ones are ours
startsecs=$(date +%s) #the time in secs since 1970


pfbFile=$1
osgxFile=$2

osgoptions=""
timeout=20

#Note, the below doesn't help this error:
#PF Fatal/Resource:             pfMalloc() Unable to allocate 560000 bytes from arena 0xa75ff000.
#If using the libpf shared memory arena,
#try using a filesystem bigger than (262144.00Kbytes).
#Use the PFTMPDIR environment variable or pfTmpDir

#This error is because pf has a cap of 260MB on the memory allocation.  The only way around is to use a c fuction to set it higher, and recompile. pfSharedArenaSize()

#export PFTMPDIR="/MarsVisionFilesystem/data"

#before we start, kill old instances of osgconv to prevent conflicts
killall osgconv

#need to cd to the .rgb directory so that we avoid warnings that it can't find the .rgb files
#.rgb files are listed without full path, so must be in same directory
ossDir=$(dirname ${pfbFile})
cd $ossDir

if [ -e $osgxFile ] ; then
    echo "WARNING: $osgxFile already exists. Overwriting."
fi

#to prevent osg from messing with the mipl mesh structure, turn off the optimizer
export OSG_OPTIMIZER="OFF"
#get some helpful information
export OSG_NOTIFY="DEBUG"

# so performer doesn't look at a vnc display fpr glx
#DISPLAY=:0  #viewpoint asu (old)
#DISPLAY=:1   #google

#performer options
#set pfSharedArenaSize, default is 256kb, but this is sometimes not enough
#from sgi archive of info-performer mailing list, topic Re: our of semaphore memory
export PFSHAREDSIZE=500000000
#export PFSEMASIZE=2000000000
export PFNFYLEVEL=7
export LD_LIBRARY_PATH=/usr/local/lib 
command="xvfb-run osgconv ${osgoptions} $pfbFile $osgxFile"
echo "xvfb-run osgconv ${osgoptions} $pfbFile $osgxFile"
#command="/opt/VirtualGL/bin/vglrun osgconv ${osgoptions} $pfbFile $osgxFile"
#command="schroot -c trusty_i386 -- /bin/bash -c \"source /home/ubuntu/.bashrc-jon && osgconv ${osgoptions} $pfbFile $osgxFile"
# starting timer in subshell. It sends a SIGUSR1 to the parent if it timeouts.
#export TIMEOUT=10
#(sleep $TIMEOUT ; kill -SIGUSR1 $PID) &
#run the command
    clean_up_semaphores
    ${command} &
id=$!
for t in {0..30} ; do
    sleep $timeout
    psout=$( ps -p ${id} | grep -vc "TIME CMD")
    #echo $( ps -p ${id})
    echo "Waiting $t"
    #echo $psout
    if [ $psout -eq 0 ] ; then break ; fi
done

while [ $psout -gt 0 ] ; do
    echo "Sending SIGTERM to process # $id and restarting."
    echo "$command"
    kill $id
    clean_up_semaphores
    #restart the command
    ${command} &
    id=$!
    for t in 0 1 2 3 4 5 6 7 8 9 ; do
        sleep $timeout
        psout=$( ps -p ${id} | grep -vc "TIME CMD")
        #echo $( ps -p ${id})
        echo "Waiting $t"
        echo $psout
        if [ $psout -eq 0 ] ; then break ; fi
    done
done

num=$(( $num+1 ))

clean_up_semaphores

exit 0

